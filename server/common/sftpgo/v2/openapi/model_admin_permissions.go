/*
SFTPGo

SFTPGo allows to securely share your files over SFTP, HTTP and optionally FTP/S and WebDAV as well. Several storage backends are supported and they are configurable per user, so you can serve a local directory for a user and an S3 bucket (or part of it) for another one. SFTPGo also supports virtual folders, a virtual folder can use any of the supported storage backends. So you can have, for example, an S3 user that exposes a GCS bucket (or part of it) on a specified path and an encrypted local filesystem on another one. Virtual folders can be private or shared among multiple users, for shared virtual folders you can define different quota limits for each user. SFTPGo allows to create HTTP/S links to externally share files and folders securely, by setting limits to the number of downloads/uploads, protecting the share with a password, limiting access by source IP address, setting an automatic expiration date. 

API version: 2.2.2-dev
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"encoding/json"
	"fmt"
)

// AdminPermissions Admin permissions:   * `*` - all permissions are granted   * `add_users` - add new users is allowed   * `edit_users` - change existing users is allowed   * `del_users` - remove users is allowed   * `view_users` - list users is allowed   * `view_conns` - list active connections is allowed   * `close_conns` - close active connections is allowed   * `view_status` - view the server status is allowed   * `manage_admins` - manage other admins is allowed   * `manage_apikeys` - manage API keys is allowed   * `quota_scans` - view and start quota scans is allowed   * `manage_system` - backups and restores are allowed   * `manage_defender` - remove ip from the dynamic blocklist is allowed   * `view_defender` - list the dynamic blocklist is allowed   * `retention_checks` - view and start retention checks is allowed   * `metadata_checks` - view and start metadata checks is allowed   * `view_events` - view and search filesystem and provider events is allowed 
type AdminPermissions string

// List of AdminPermissions
const (
	ADMINPERMISSIONS_STAR AdminPermissions = "*"
	ADMINPERMISSIONS_ADD_USERS AdminPermissions = "add_users"
	ADMINPERMISSIONS_EDIT_USERS AdminPermissions = "edit_users"
	ADMINPERMISSIONS_DEL_USERS AdminPermissions = "del_users"
	ADMINPERMISSIONS_VIEW_USERS AdminPermissions = "view_users"
	ADMINPERMISSIONS_VIEW_CONNS AdminPermissions = "view_conns"
	ADMINPERMISSIONS_CLOSE_CONNS AdminPermissions = "close_conns"
	ADMINPERMISSIONS_VIEW_STATUS AdminPermissions = "view_status"
	ADMINPERMISSIONS_MANAGE_ADMINS AdminPermissions = "manage_admins"
	ADMINPERMISSIONS_MANAGE_APIKEYS AdminPermissions = "manage_apikeys"
	ADMINPERMISSIONS_QUOTA_SCANS AdminPermissions = "quota_scans"
	ADMINPERMISSIONS_MANAGE_SYSTEM AdminPermissions = "manage_system"
	ADMINPERMISSIONS_MANAGE_DEFENDER AdminPermissions = "manage_defender"
	ADMINPERMISSIONS_VIEW_DEFENDER AdminPermissions = "view_defender"
	ADMINPERMISSIONS_RETENTION_CHECKS AdminPermissions = "retention_checks"
	ADMINPERMISSIONS_METADATA_CHECKS AdminPermissions = "metadata_checks"
	ADMINPERMISSIONS_VIEW_EVENTS AdminPermissions = "view_events"
)

// All allowed values of AdminPermissions enum
var AllowedAdminPermissionsEnumValues = []AdminPermissions{
	"*",
	"add_users",
	"edit_users",
	"del_users",
	"view_users",
	"view_conns",
	"close_conns",
	"view_status",
	"manage_admins",
	"manage_apikeys",
	"quota_scans",
	"manage_system",
	"manage_defender",
	"view_defender",
	"retention_checks",
	"metadata_checks",
	"view_events",
}

func (v *AdminPermissions) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := AdminPermissions(value)
	for _, existing := range AllowedAdminPermissionsEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid AdminPermissions", value)
}

// NewAdminPermissionsFromValue returns a pointer to a valid AdminPermissions
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewAdminPermissionsFromValue(v string) (*AdminPermissions, error) {
	ev := AdminPermissions(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for AdminPermissions: valid values are %v", v, AllowedAdminPermissionsEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v AdminPermissions) IsValid() bool {
	for _, existing := range AllowedAdminPermissionsEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to AdminPermissions value
func (v AdminPermissions) Ptr() *AdminPermissions {
	return &v
}

type NullableAdminPermissions struct {
	value *AdminPermissions
	isSet bool
}

func (v NullableAdminPermissions) Get() *AdminPermissions {
	return v.value
}

func (v *NullableAdminPermissions) Set(val *AdminPermissions) {
	v.value = val
	v.isSet = true
}

func (v NullableAdminPermissions) IsSet() bool {
	return v.isSet
}

func (v *NullableAdminPermissions) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableAdminPermissions(val *AdminPermissions) *NullableAdminPermissions {
	return &NullableAdminPermissions{value: val, isSet: true}
}

func (v NullableAdminPermissions) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableAdminPermissions) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

